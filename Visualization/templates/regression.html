<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<title>Regression Graphs</title>
		<script src="http://mbostock.github.com/d3/d3.v2.js"></script>
  		<style> /* set the CSS */

	  		body { font: 12px Arial;}

	  		/* tell the SVG path to be a thin blue line without any area fill */
	  		path {
	  			stroke: steelblue;
	  			stroke-width: 1;
	  			fill: none;
	  		}
	  		
	  		.axis {
	  		  shape-rendering: crispEdges;
	  		}
	  		
	  		.x.axis line {
	  		  stroke: lightgrey;
	  		}
	  		
	  		.x.axis .minor {
	  		  stroke-opacity: .5;
	  		}
	  		
	  		.x.axis path {
	  		  display: none;
	  		}
	  		
	  		.y.axis line, .y.axis path {
	  		  fill: none;
	  		  stroke: #000;
	  		}
/*  			body {
  				font: 10px sans-serif;
  			}
  			.line {
				stroke: steelblue;
				stroke-width: 1;
				fill: none;
			}
			
			.axis {
				fill:none;
				stroke: #000;
			  shape-rendering: crispEdges;
			}
			.x.axis line {
			  stroke: lightgrey;
			}
			.x.axis .minor {
			  stroke-opacity: .5;
			}
			.x.axis path {
			  display: none;
			}
			.y.axis line, .y.axis path {
			  fill: none;
			  stroke: #000;
			}*/

  		</style>
	</head>
	<body>
		<h1 align="center" id="info"></h1> 
		<div id="graph" class="aGraph" style="position:absolute;top:0px;left:0; float:left;">
		<script src="https://d3js.org/d3.v3.min.js"></script>
		
		<script>

		polydata = {{ poly1data|safe }};


		var keys = Object.keys(polydata)
		var values = []
		for (var i = 0; i < keys.length; i++) {
			values.push(polydata[keys[i]])
		}
		/* implementation heavily influenced by http://bl.ocks.org/1166403 */
		
		max = Math.max.apply(null, values);
		min = Math.min.apply(null, values);

		// define dimensions of graph
		var m = [100, 20, 30, 100]; // margins
		var w = 1500 - m[1] - m[3]; // width
		var h = 900 - m[0] - m[2]; // height
		
		// create a simple data array that we'll plot with a line (this array represents only the Y values, X will just be the index location)
 
		// X scale will fit all values from data[] within pixels 0-w
		//var x = d3.scale.linear().domain(["1960", "2014"]).range([0, w]);
		//var x = d3.scale.ordinal().rangePoints([0, width]);
		var timeFormat = d3.time.format('%Y');
		var x = d3.time.scale().domain([timeFormat.parse('1960'), timeFormat.parse('2014')]).range([0, w])
		//var x = d3.scale.ordinal().domain(keys).rangePoints([0, w]);
		//var x = d3.scale.linear().domain(keys.map(function(d) { return d; })).range([0, w]);
		// Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
		var y = d3.scale.linear().domain([min, max]).range([h, 0]);

 
		// create a line function that can convert data[] into x and y points
		var line = d3.svg.line()
			// assign the X function to plot our line as we wish
			.x(function(d,i) { 
				// verbose logging to show what's actually being done
				// return the X coordinate where we want to plot this datapoint
				//console.log(x(i))
				console.log(x(keys[i]))
				return x(timeFormat.parse(keys[i])); 
			})
			.y(function(d) { 
				// verbose logging to show what's actually being done
				// return the Y coordinate where we want to plot this datapoint
				console.log(y(d))
				return y(d); 
			});
 
 

		// Add an SVG element with the desired dimensions and margin.
		var graph = d3.select("#graph").append("svg:svg")
		      .attr("width", w + m[1] + m[3])
		      .attr("height", h + m[0] + m[2])
		    .append("svg:g")
		      .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

		// create yAxis
		var xAxis = d3.svg.axis().scale(x).ticks(20).tickSize(-h);
		// Add the x-axis.
		graph.append("svg:g")
		      .attr("class", "x axis")
		      .attr("transform", "translate(0," + h + ")")
		      .call(xAxis);


		// create left yAxis
		var yAxisLeft = d3.svg.axis().scale(y).ticks(20).orient("left");
		// Add the y-axis to the left
		graph.append("svg:g")
		      .attr("class", "y axis")
		      .attr("transform", "translate(-25,0)")
		      .call(yAxisLeft);
		
			// Add the line by appending an svg:path element with the data line we created above
		// do this AFTER the axes above so that the line is above the tick-lines
		graph.append("svg:path").attr("d", line(values));
			
 

		// // Set the dimensions of the canvas / graph
		// var margin = {top: 30, right: 20, bottom: 30, left: 50},
		//     width = 900 - margin.left - margin.right,
		//     height = 900 - margin.top - margin.bottom;

		// // Parse the date / time

		// // Set the ranges
		// var x = d3.scale.linear().range([0, width]);
		// var y = d3.scale.linear().range([height, 0]);

		// // Define the axes
		// var xAxis = d3.svg.axis().scale(x)
		//     .orient("bottom").ticks(5);

		// var yAxis = d3.svg.axis().scale(y)
		//     .orient("left").ticks(5);

		// // Define the line
		// var valueline = d3.svg.line()
		//     .x(function(d) { return x(d.date); })
		//     .y(function(d) { return y(d.close); });
		    
		// // Adds the svg canvas
		// var svg = d3.select("body")
		//     .append("svg")
		//         .attr("width", width + margin.left + margin.right)
		//         .attr("height", height + margin.top + margin.bottom)
		//     .append("g")
		//         .attr("transform", 
		//               "translate(" + margin.left + "," + margin.top + ")");

		// // Get the data

		// x.domain(data.map(function(d) { return parseInt(d.letter, 10); }));
		// y.domain(data.map(function(d) { return parseInt(d.frequency, 10); }));
	 //    // Scale the range of the data
	 //    // x.domain(d3.extent(data, function(d) { return d.date; }));
	 //    // y.domain([0, d3.max(data, function(d) { return d.close; })]);

	 //    // Add the valueline path.
	 //    svg.append("path")
	 //        .attr("class", "line")
	 //        .attr("d", valueline(data));

	 //    // Add the X Axis
	 //    svg.append("g")
	 //        .attr("class", "x axis")
	 //        .attr("transform", "translate(0," + height + ")")
	 //        .call(xAxis);

	 //    // Add the Y Axis
	 //    svg.append("g")
	 //        .attr("class", "y axis")
	 //        .call(yAxis);





		// var data = []
		// var years = []
		// for (var j = 1960; j < 2015; j++){
		// 	years.push(j.toString())
		// }

		// for (var i = 0; i < years.length; i++){
		// 	data.push(polydata[years[i]])
		// }
		// var dmin = Math.min(data)
		// var dmax = Math.max(data)

		// document.getElementById("info").innerHTML = data[3] + " " + polydata["2006"] + " " + dmin

		// var margin = {top: 20, right: 20, bottom: 30, left: 50},
  //   	width = 960 - margin.left - margin.right,
  //   	height = 500 - margin.top - margin.bottom;

		// var formatDate = d3.time.format("%Y");

		// var x = d3.time.scale().range([0, w]);
		// var y = d3.scale.linear().range([h, 0]);

		// var xAxis = d3.svg.axis()
		//     .scale(x)
		//     .orient("bottom");

		// var yAxis = d3.svg.axis()
		//     .scale(y)
		//     .orient("left");

		// var line = d3.svg.line()
  //   		.x(function(d) { return x(d.date); })
  //   		.y(function(d) { return y(d.close); });

  //   	var svg = d3.select("body").append("svg")
	 //    	.attr("width", width + margin.left + margin.right)
	 //    	.attr("height", height + margin.top + margin.bottom)
	 //  	.append("g")
	 //    	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");









    	</script>
	</body>
</html>